# 012.features.01: Domain Knowledge & Learned Assertions

**Status:** Pending
**Priority:** Medium
**Depends On:** 011.features.01 (Batch Action Execution)

## Objective

Observe and record state changes (DOM deltas) that occur after each action during execution. On subsequent visits to the same domain, use these recorded observations as assertions to enable faster, more confident batch execution — and bail out to re-sensing when reality diverges from expectations.

## Context

Abra currently treats every page visit as a blank slate. Even if it has visited google.com 50 times, it runs the same slow sense-plan-act loop every time. With domain knowledge, Abra's speed on a domain becomes a reflection of how stable that domain is — stable sites get faster over time, volatile sites stay appropriately cautious.

This feature implements **optimistic execution with incremental learning**:

1. **Cold start (no knowledge)**: Slow mode — sense → plan → execute → sense → repeat. Every action produces a state delta observation that gets logged. This is exactly how Abra works today, so cold start = current behavior.

2. **Warm (has knowledge)**: Fast mode — plan batch → execute with assertions from previous observations. Between each action, check: "did reality match what I learned last time?" If yes, continue at speed. If no, stop, observe what actually happened, update the record, resume.

3. **Piecemeal updates**: When an assertion fails, Abra doesn't discard everything it knows. It patches only the specific transition that changed. If google.com redesigns search results but the search input still works the same, only post-search assertions update. Everything upstream stays valid.

**Key design principle**: No expiry dates. Knowledge is never "stale" — it's either confirmed or corrected on contact. The last-confirmed timestamp is tracked for observability, not for invalidation.

## Technical Details

### Concepts

**Transition Record**: The atomic unit of domain knowledge.

```typescript
interface TransitionRecord {
  domain: string;                    // e.g., "google.com"
  pagePath: string;                  // Exact URL path (no fuzzy matching)
  action: {
    type: ActionType;                // click, type, press, etc.
    signature: ElementSignature;     // Semantic identity (not CSS selector)
    text?: string;                   // For type actions
    key?: string;                    // For press actions
  };
  expectedOutcome: StateDelta;       // What happened last time
  lastConfirmed: string;             // ISO timestamp of last successful assertion
  confirmCount: number;              // Times this assertion has passed
  failCount: number;                 // Times this assertion has failed and been updated
}

interface ElementSignature {
  tagName: string;                   // e.g., "INPUT", "BUTTON"
  role?: string;                     // ARIA role
  ariaLabel?: string;                // aria-label value
  testId?: string;                   // data-testid (strongest anchor)
  textContent?: string;              // Truncated to 50 chars
  nthOfType?: number;                // Position among siblings of same tag
}
```

**State Delta**: What changed after an action. Intentionally narrow — captures structural outcomes, ignores cosmetic noise.

```typescript
interface StateDelta {
  focusChanged?: {
    gainedFocus?: ElementSignature;  // Semantic identity of focused element
  };
  ariaChanges?: Array<{             // Only aria-* and data-* attributes (stable, semantic)
    signature: ElementSignature;
    attribute: string;               // e.g., "aria-expanded", "data-loading"
    newValue: string | null;
  }>;
  visibilityChanges?: Array<{       // Elements that appeared or disappeared in target's container
    signature: ElementSignature;
    appeared: boolean;
  }>;
  urlChanged?: {
    to: string;                      // New URL (don't store "from" — it's in context)
  };
  newContentLoaded?: boolean;        // data-loading went from true → false
}
```

**Excluded from deltas** (too noisy, non-deterministic):
- CSS class changes (framework-generated, change per build)
- Style attribute changes (animations, transitions)
- Elements outside the target element's parent container (ads, analytics, unrelated lazy-loads)
- Scroll position changes (viewport-dependent)

### Architecture

```
┌─────────────────────────────────────────┐
│           Domain Knowledge Store         │
│  (JSON files per domain in data/domains/)│
│                                         │
│  google.com.json                        │
│  etsy.com.json                          │
│  ...                                    │
└───────────┬──────────────┬──────────────┘
            │              │
     ┌──────┴─────┐  ┌────┴──────┐
     │  Observer   │  │  Asserter  │
     │ (captures   │  │ (checks    │
     │  deltas)    │  │  expected   │
     │             │  │  vs actual) │
     └──────┬─────┘  └────┬──────┘
            │              │
      ┌─────┴──────────────┴─────┐
      │    executeBatch() loop    │
      │  (from 011.features.01)  │
      └──────────────────────────┘
```

### Files to Create

| File | Purpose |
|------|---------|
| `src/lib/domain-knowledge.ts` | `DomainKnowledgeStore` class — CRUD for transition records, matching logic, persistence |
| `src/lib/state-observer.ts` | `captureStateDelta()` — snapshot DOM state before/after action, compute diff |

### Files to Modify

| File | Changes |
|------|---------|
| `src/lib/session.ts` | Integrate observer and asserter into `executeBatch()` loop |
| `src/lib/llm.ts` | Optionally include domain knowledge context in prompts (e.g., "on this domain, clicking X typically causes Y") |
| `src/cli.ts` | Add `--no-learn` flag to disable knowledge recording (useful for debugging) |
| `src/index.ts` | Export new types |

### Implementation Steps

#### Step 1: State Observer (`src/lib/state-observer.ts`)

A module that captures DOM state changes after an action, producing a `StateDelta`.

**Approach: MutationObserver-based** (not before/after snapshots — too expensive)

Instead of two `evaluate()` calls per action, use a single setup + teardown:
1. **Before action**: Install a `MutationObserver` on the target element's parent container via one `evaluate()` call. Also snapshot: `document.activeElement`, current URL, container's visible children.
2. **Execute action** (normal flow)
3. **After action**: Collect `MutationObserver` records + new `activeElement` + new URL via one `evaluate()` call. Compute delta from the collected mutations.

**Shared observer with `waitForDOMSettle()` (from 013.core.01)**: The DOM settle detector installs a `MutationObserver` on `document.body` to detect when mutations stop. This observer and the state delta observer can be **combined into a single observer** — it collects mutations for delta computation AND detects settle (no mutations for 100ms = done). This avoids installing two observers per action and ensures the delta captures all mutations up to the point of settle.

This reduces browser round-trips from 2 expensive snapshot calls to 2 lightweight setup/teardown calls, with the browser itself doing the observation.

**Scope**: Target element's parent container only. Changes outside this container are ignored (too noisy).

**Budget**: If observation adds >100ms per action, it's too expensive. Measure in practice. If over budget, only observe when learning (no existing knowledge for this transition).

```typescript
export async function installObserver(
  browser: Browser,
  action: Action,
  containerSelector: string
): Promise<void>  // installs MutationObserver + snapshots baseline

export async function collectObservation(
  browser: Browser
): Promise<StateDelta>  // collects mutations, computes delta, tears down observer
```

**Only observe successful actions.** If `executeAction()` returns `{ success: false }`, call teardown without recording. Failed actions produce noise, not knowledge.

#### Step 2: Domain Knowledge Store (`src/lib/domain-knowledge.ts`)

Persistent storage for transition records.

```typescript
export class DomainKnowledgeStore {
  constructor(dataDir: string);  // e.g., ~/.abra/domains/ or configurable

  // Lookup: find matching transition for this action on this domain
  findTransition(domain: string, pagePath: string, action: ActionSignature): TransitionRecord | null;

  // Record: save an observed transition
  recordTransition(record: TransitionRecord): void;

  // Update: patch a transition when assertion fails
  updateTransition(record: TransitionRecord, newDelta: StateDelta): void;

  // Persistence
  async load(domain: string): Promise<void>;
  async save(domain: string): Promise<void>;
}
```

**Matching logic**: When looking up a transition, match by:
1. Domain (exact)
2. Page path (exact — no fuzzy URL matching initially; see Risk 6)
3. Action type + **semantic signature** (not CSS selector)

**Semantic signature** = `{tagName, role, aria-label, data-testid, textContent (truncated), nthOfType within parent}`. These attributes are more stable across deploys than generated CSS class names. `data-testid` is the strongest anchor when available.

Start with exact signature matching. If it proves too strict, relax individual fields (e.g., ignore `nthOfType` if other fields match).

#### Step 3: Integration into executeBatch() (`src/lib/session.ts`)

Modify the batch execution loop from 011.features.01:

```
for each action in batch:
  1. Pre-flight checks (existing: element exists, URL stable)
  2. NEW: Install MutationObserver on target's container
  3. Execute action
  4. If action FAILED: tear down observer (don't record), bail per existing 011 logic
  5. NEW: Collect observation → StateDelta
  6. NEW: If domain knowledge exists for this transition:
     a. Compare actual delta against expected delta (similarity threshold, not exact match)
     b. If match: continue (fast path), update lastConfirmed timestamp
     c. If structural mismatch: record the new delta, bail to re-sensing
  7. NEW: If no domain knowledge exists:
     a. Record this transition as new knowledge
     b. Continue normally
```

**Similarity matching**: An assertion passes if all expected structural changes are present in the actual delta. Extra changes in the actual delta (additive noise) are ignored. Missing expected changes trigger assertion failure.

The bail-on-assertion-failure integrates with the existing bail-out system from 011 — it's just an additional trigger alongside "action failed", "URL changed", and "element missing".

#### Step 4: CLI Flag (`src/cli.ts`)

Add `--no-learn` flag that disables both recording and asserting. Useful for:
- Debugging (isolate whether domain knowledge is causing issues)
- One-off sessions where you don't want to pollute the knowledge base

#### Step 5: Prompt Context — DEFERRED

~~Optionally include domain knowledge in the LLM prompt to help batching decisions.~~

**Deferred to a future iteration.** The mechanical assertion system (observe → assert → correct) is self-healing — wrong knowledge gets corrected on contact. But injecting wrong knowledge into the LLM prompt causes cascading bad decisions that aren't self-correcting. Get the mechanical system working and validated first. Only add prompt injection after the knowledge base has proven reliable in practice.

### Known Risks and Mitigations

#### Risk 1: Selector instability makes matching near-impossible (HIGH — potential showstopper)

The entire feature depends on matching "this action on this page" to a previously recorded transition. But selectors change between deploys: `button.css-1a2b3c` becomes `button.css-4d5e6f`. Even IDs and class names shift on modern CI/CD sites.

Starting with exact match means v1 will almost never find matches on real, frequently-deployed websites. The feature is effectively disabled until matching works.

**Mitigations:**
- **Don't match by CSS selector.** Match by a **semantic signature**: `{tagName, role, aria-label, data-testid, textContent, nthOfType}`. These are more stable across deploys than generated class names.
- `data-testid` is the most reliable anchor — sites that use it (including all Puppet-tested sites) will get the best matching.
- For sites without `data-testid`, fall back to `{tagName + textContent + parentContext}`. This is lossy but better than CSS selectors.
- Accept that some sites will never have stable enough identifiers for matching. The system degrades gracefully — no match found = cold start behavior.

#### Risk 2: State deltas are noisy and non-deterministic (HIGH)

A click on a search field triggers: focus event + autocomplete dropdown + analytics pixel + lazy-loaded ad. Next visit, the ad is different. Delta doesn't match. Assertion fails. On real sites with ads, A/B tests, and personalization, assertion failure becomes the norm.

**Mitigations:**
- **Narrow the delta to structural changes only**: focus changes, `aria-*` attribute changes, element visibility changes on the target and its direct container. Ignore: class changes (too noisy), style changes (animations), elements outside the target's parent container.
- **Use a similarity threshold, not exact match**: if 3 of 4 expected changes match, treat as a pass. Only bail if the *structural* outcome is different (e.g., expected a dropdown to appear but nothing appeared).
- **Ignore additive noise**: if the expected delta is "element gained focus" and the actual delta is "element gained focus + 3 unrelated elements appeared elsewhere," that's still a pass. Extra changes are fine; missing expected changes are what trigger bail.

#### Risk 3: Observation overhead may negate performance gains (MEDIUM)

Each `browser.evaluate()` call costs 10-50ms. Pre-snapshot + post-snapshot = 2 calls per action. In a 4-action batch, that's 8 extra `evaluate()` calls = 160-400ms overhead. If this approaches the time saved by skipping one sensing cycle, the feature is net-negative.

**Mitigations:**
- **Combine pre/post snapshot into a single evaluate call** that returns a self-contained diff. Install a MutationObserver before the action and collect results after. One `evaluate()` call to set up, one to tear down.
- **Only observe when learning** (no existing knowledge for this transition). Once a transition has been confirmed N times, stop observing it — the cost of observation is wasted on stable transitions.
- **Budget**: if observation adds >100ms per action, it's too expensive. Measure in practice and adjust scope.

#### Risk 4: Learning from errors creates negative feedback loops (MEDIUM)

If an action fails or produces unexpected results, the delta is still recorded. On the next visit, the system expects the broken state. When the site works correctly, the assertion "fails" because reality doesn't match the recorded broken behavior.

**Mitigation:**
- **Only record transitions from successful actions.** If `executeAction()` returns `{ success: false }`, skip recording. The delta from a failed action is noise, not knowledge.
- Also skip recording when the batch bailed — the post-bail state is not representative of normal behavior.

#### Risk 5: Concurrent sessions cause silent data loss (MEDIUM)

Two sessions on the same domain both load the JSON at session start. Session A writes a transition. Session B overwrites the file with its version, losing A's data. This isn't just a race — it's guaranteed data loss when running parallel sessions.

**Mitigations:**
- **Append-only log per session**, merged on read. Each session writes to `google.com.<sessionId>.jsonl`. On load, merge all log files for a domain. This eliminates write conflicts entirely.
- Alternatively, use a simple file lock (advisory flock). But append-log is simpler and more robust.

#### Risk 6: URL fuzzy matching is error-prone (LOW)

`/product/shoes` is a category, `/product/12345` is a product ID. Heuristics can't reliably distinguish parameters from path segments. Wrong matching applies knowledge from one page to a different page.

**Mitigation:**
- Start with **exact path matching**. Don't try to be smart about parameterized URLs until there's evidence it's needed. If a product page changes between `/product/123` and `/product/456`, those are separate entries in the knowledge base. The cost is redundant storage, not wrong behavior.
- If fuzzy matching is added later, require explicit opt-in patterns per domain, not automatic inference.

#### Risk 7: Knowledge → LLM prompt injection is actively dangerous (LOW)

Step 5 proposes including domain knowledge in the LLM prompt. If the knowledge is stale or wrong, it actively misleads the LLM. Unlike mechanical assertions (self-correcting on contact), wrong LLM context causes cascading bad decisions.

**Mitigation:**
- **Defer Step 5 to a future iteration.** The mechanical assertion system (observe + assert + correct) is self-healing. The LLM prompt injection is not. Get the mechanical system working first. Only add prompt injection after the knowledge base has been validated to be reliable in practice.

### Edge Cases

| Case | Handling |
|------|----------|
| First visit to a domain | No knowledge exists. All actions are observed and recorded. Execution speed = current behavior |
| Assertion fails on one transition | Only that transition is updated. All other knowledge for the domain stays valid |
| Selector changed between visits | Match by semantic signature (tagName, role, aria-label, data-testid, textContent), not CSS selector. If no match, treated as new transition |
| Site redesign (many assertions fail) | Multiple transitions get updated in one session. Abra slows down locally at changed areas, stays fast at unchanged areas |
| Dynamic content (user-specific) | Deltas limited to structural changes (focus, aria-*, visibility). Ignore class/style noise. Use similarity threshold, not exact match |
| Action failed | **Do not record.** Only learn from successful actions. Failed actions produce noise, not knowledge |
| `--no-learn` flag | Observer and asserter both disabled. Pure execution with bail-out checks only (011 behavior) |
| Concurrent sessions on same domain | Append-only log per session (`domain.<sessionId>.jsonl`), merged on read. Eliminates write conflicts |
| One-off sites / file growth | Track last-accessed timestamp per domain file. Provide a `prune` CLI command that removes domain files not accessed in N days. Don't auto-prune — that's a user decision |

### Data Storage

**Location**: `~/.abra/domains/` (global, shared across projects) or configurable via CLI.

**Format**: Append-only log files per session, merged on read:
```
~/.abra/domains/
  google.com/
    transitions.jsonl          # Merged canonical file
    session-abc123.jsonl       # Per-session append logs (merged periodically)
  etsy.com/
    transitions.jsonl
```

Each session appends to its own log file. On startup, the store merges all session logs into the canonical file (last-write-wins per transition key). This eliminates concurrent write conflicts — multiple sessions can write simultaneously without data loss.

**Size management**: Transition records with `ElementSignature` and narrowed `StateDelta` are ~300-800 bytes each. Complex pages (dropdowns with many items) can produce larger `visibilityChanges` arrays — cap at 10 entries per delta.

**Pruning**: Track `lastAccessed` timestamp per domain directory. Provide a `abra prune --older-than 90d` CLI command to remove stale domain files. Don't auto-prune.

### Progression Model

```
Visit 1: 100% sensing, 0% assertions → Slow but thorough
Visit 2: Many assertions available → Fast where knowledge exists, slow at new pages
Visit N: Rich knowledge base → Very fast on known flows
Site redesign: Assertions fail locally → Abra slows down, learns new patterns, speeds back up
```

Abra's speed on a given domain is a direct reflection of how stable that domain is.

## Testing

- Verify cold start (no knowledge file) behaves identically to current behavior
- Verify transitions are recorded after successful actions only (failed actions must not be recorded)
- Verify assertions pass on repeated identical page visits
- Verify assertion failure triggers re-sensing (not crash)
- Verify piecemeal update: change one element on a page, confirm only that transition updates
- Verify `--no-learn` disables all knowledge recording and assertion checking
- Verify knowledge persists across sessions (file-based)
- **Semantic matching**: Verify that `ElementSignature` matching works when CSS selectors change but `data-testid` stays the same
- **Similarity threshold**: Verify that additive noise (extra elements appearing) doesn't trigger assertion failure — only missing expected changes should trigger bail
- **Concurrent sessions**: Run two sessions on the same domain simultaneously, verify no data loss in the merged knowledge file
- **Observation overhead**: Measure wall-clock time per action with observation enabled vs. disabled. If overhead >100ms, the scope is too wide
- **Negative feedback loop**: Deliberately fail an action, verify the failed delta is NOT recorded, verify the next visit doesn't assert on broken state

## Future Directions

- **Abra → Puppet test generation**: Transition records are the raw material for writing deterministic test assertions. Pipeline: Abra explores → learns transitions → exports as Puppet test scripts (connects to Task 16 research)
- **Confidence weighting**: Transitions confirmed many times could be trusted more, allowing even faster execution (skip some pre-flight checks)
- **Cross-domain patterns**: "Search fields generally gain focus when clicked" could generalize across domains
- **Knowledge sharing**: Export/import domain knowledge between Abra installations

## Dependencies

- **013.core.01 (Adaptive DOM Settle Detection)**: Provides `waitForDOMSettle()` whose MutationObserver can be shared with the state delta observer — settle detection collects the same mutations needed for learning.
- **011.features.01 (Batch Action Execution)**: This feature extends the `executeBatch()` loop with observation and assertion hooks. Without batch execution, there's no execution loop to hook into.
