# 013.core.01: Adaptive DOM Settle Detection

**Status:** Pending
**Priority:** High

## Objective

Replace the fixed `waitForLoaded(2000)` timeout with an adaptive `waitForDOMSettle()` that uses `MutationObserver` to detect when the DOM has actually stopped changing. This gives fast pages fast execution and slow pages appropriate patience, without a fixed delay to tune.

## Context

After every action, Abra currently calls `browser.waitForLoaded(2000)` — a fixed 2-second timeout provided by puppet. This is a blunt instrument:

- **Too slow for simple actions**: Clicking a checkbox on a static page settles in <20ms, but Abra waits up to 2 seconds.
- **Too fast for complex actions**: Clicking a button that triggers an API call + React re-render may need >2 seconds.
- **Not adaptive**: The same timeout applies to every action on every site, regardless of what actually happens in the DOM.

`waitForDOMSettle()` replaces this with a `MutationObserver`-based approach that resolves when mutations stop arriving. The wait time tracks reality — fast pages go fast, slow pages get patience.

**This is independently valuable.** It improves the current single-action loop today, and becomes the foundation for inter-action timing in Task 17 (Batch Action Execution) and the shared observer in Task 18 (Domain Knowledge).

## Technical Details

### Core Implementation

The function is injected into the page via `browser.evaluate()` — no changes to puppet required.

```typescript
// Injected into page context via browser.evaluate()
function waitForDOMSettle(timeout = 2000, quietPeriod = 100): Promise<void> {
  return new Promise((resolve) => {
    let timer: ReturnType<typeof setTimeout>;
    let hardTimeout: ReturnType<typeof setTimeout>;

    const observer = new MutationObserver(() => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        observer.disconnect();
        clearTimeout(hardTimeout);
        resolve();
      }, quietPeriod); // no mutations for quietPeriod ms = settled
    });

    observer.observe(document.body, {
      childList: true, subtree: true,
      attributes: true, characterData: true
    });

    // Hard cap — never wait forever
    hardTimeout = setTimeout(() => {
      observer.disconnect();
      clearTimeout(timer);
      resolve();
    }, timeout);

    // If nothing mutates at all, resolve after quietPeriod
    timer = setTimeout(() => {
      observer.disconnect();
      resolve();
    }, quietPeriod);
  });
}
```

### How It Behaves

| Scenario | Current (`waitForLoaded`) | With `waitForDOMSettle` |
|----------|--------------------------|------------------------|
| Click checkbox on static page | Up to 2s | ~20ms |
| Type into React input | Up to 2s | ~100-150ms (framework render cycle) |
| Click triggers API call + skeleton | Up to 2s (may be too short) | ~500ms-2s (waits for content to load) |
| Chatty site (ads, analytics, live chat) | Up to 2s | 2s (hard cap, same as today) |
| Page with infinite CSS animations | Up to 2s | 2s (hard cap) or ~100ms if structural mutations stop |

**Worst case matches current behavior.** The hard cap ensures no regression — chatty sites that always mutate get the same 2s timeout as today. But well-behaved sites get dramatically faster execution.

### Files to Create

| File | Purpose |
|------|---------|
| `src/lib/dom-settle.ts` | `waitForDOMSettle()` wrapper — injects the script via `browser.evaluate()`, returns a promise |

### Files to Modify

| File | Changes |
|------|---------|
| `src/lib/session.ts` | Replace `browser.waitForLoaded(2000)` calls with `waitForDOMSettle(browser)` |
| `src/lib/action-executor.ts` | Remove `waitForLoaded` from the `Browser` interface if no longer needed (check puppet dependency first) |
| `src/index.ts` | Export `waitForDOMSettle` |

### Implementation Steps

#### Step 1: Create `src/lib/dom-settle.ts`

```typescript
import type { Browser } from './action-executor.js';

export interface DOMSettleOptions {
  /** Max wait time in ms. Default: 2000 */
  timeout?: number;
  /** How long mutations must be quiet before resolving. Default: 100 */
  quietPeriod?: number;
}

/**
 * Wait for the DOM to stop changing after an action.
 * Uses MutationObserver injected into the page context.
 */
export async function waitForDOMSettle(
  browser: Browser,
  options: DOMSettleOptions = {}
): Promise<void> {
  const { timeout = 2000, quietPeriod = 100 } = options;

  await browser.evaluate(`
    new Promise((resolve) => {
      let timer;
      let hardTimeout;

      const observer = new MutationObserver(() => {
        clearTimeout(timer);
        timer = setTimeout(() => {
          observer.disconnect();
          clearTimeout(hardTimeout);
          resolve();
        }, ${quietPeriod});
      });

      observer.observe(document.body, {
        childList: true, subtree: true,
        attributes: true, characterData: true
      });

      hardTimeout = setTimeout(() => {
        observer.disconnect();
        clearTimeout(timer);
        resolve();
      }, ${timeout});

      timer = setTimeout(() => {
        observer.disconnect();
        resolve();
      }, ${quietPeriod});
    });
  `);
}
```

#### Step 2: Replace `waitForLoaded` in `session.ts`

Current usage (two call sites):
- Line ~127: `await browser.waitForLoaded(2000);` — after initial page load
- Line ~409: `await browser.waitForLoaded(2000);` — after each action execution

Replace both with `await waitForDOMSettle(browser);`

**Note on initial page load**: The first call (line ~127) fires after `browser.goto()`. For initial page loads, `waitForLoaded()` may still be appropriate since it checks `document.readyState`. Consider keeping `waitForLoaded()` for initial navigation and using `waitForDOMSettle()` only for post-action settling. Test both approaches.

#### Step 3: Verify `waitForLoaded` can be kept for navigation

`waitForLoaded()` comes from puppet's Browser interface. It likely checks `document.readyState === 'complete'` or similar — useful for full page loads. `waitForDOMSettle()` is better for post-action DOM changes where the page is already loaded. The two serve different purposes:

- `waitForLoaded()` → after navigation (goto, link click that causes full page load)
- `waitForDOMSettle()` → after in-page actions (click button, type, interact)

If an action causes navigation (detected by URL change), fall back to `waitForLoaded()` since MutationObserver on the old page is useless after navigation.

### Known Risks and Mitigations

#### Risk 1: Chatty DOMs always hit the hard cap (MEDIUM)

Sites with ads, analytics pixels, live chat widgets, or animated backgrounds mutate constantly. The MutationObserver never goes quiet, always hitting the 2s hard cap.

**Impact:** On these sites, every post-action wait becomes 2s — same as current behavior, so no regression, but no improvement either.

**Mitigations:**
- Accept 2s hard cap as safe default. Worst case = current behavior.
- **Future iteration: Scoped observer.** Instead of `document.body`, observe only the subtree near the action target. Mutations in an ad sidebar are irrelevant when interacting with a search form. This requires passing the action's target selector to the settle function.
- **Future iteration: Mutation filtering.** Ignore attribute-only mutations on elements matching patterns like `[data-ad]`, `[data-analytics]`, `iframe`, or elements with no visible dimensions.

#### Risk 2: React/Vue batch rendering causes false-settle (LOW)

Frameworks batch state updates: mutation burst → 16ms gap → second burst. The 100ms quiet period should handle this (16ms < 100ms), but edge cases exist:
- `useEffect` with `setTimeout(fn, 0)` — the effect fires after a full frame, potentially after a >100ms gap
- Suspense boundaries that load asynchronously

**Mitigations:**
- 100ms quiet period is conservative enough for most framework rendering.
- If false-settles are observed in practice, increase `quietPeriod` to 150ms or 200ms. This is a tunable parameter, not a code change.
- The action that follows a false-settle will encounter a stale DOM, which the existing error handling (action failure → retry) catches.

#### Risk 3: Navigation kills the observer (LOW)

If an action causes a full page navigation, the MutationObserver is destroyed along with the old page. The `evaluate()` call may reject or hang.

**Mitigation:**
- Wrap the `evaluate()` call in a try/catch. If it rejects (page navigated), resolve immediately — the navigation itself is the "settle" signal.
- Alternatively, race the settle promise against a navigation detection check.

#### Risk 4: `document.body` may not exist yet (EDGE)

On very early page loads or about:blank pages, `document.body` may be null.

**Mitigation:**
- Add a guard: `if (!document.body) resolve();` — if there's no body, there's nothing to observe.

### Tuning Parameters

| Parameter | Default | When to adjust |
|-----------|---------|----------------|
| `timeout` | 2000ms | Increase for sites with heavy async loading. Decrease if 2s feels too long for simple pages. |
| `quietPeriod` | 100ms | Increase if false-settles observed (framework re-renders arriving after 100ms gap). Decrease if sites feel slow on simple interactions. |

These are exposed as options on `waitForDOMSettle()` so callers can override per-context. The defaults should work for 80%+ of sites.

### Future Iterations (not in scope for this task)

1. **Scoped observer**: Pass the action target's selector, observe only its parent subtree. Eliminates chatty-DOM false positives.
2. **Animation-aware settle**: Check `document.getAnimations().filter(a => a.playState === 'running')` for structural animations (not decorative). Settle when both mutations stop AND relevant animations complete.
3. **Network-idle integration**: Track `fetch`/`XMLHttpRequest` calls initiated after the action. Settle when mutations stop AND no pending requests. Requires injecting request interceptors.
4. **Settle metrics**: Log settle times per action for analysis. "This site averages 45ms settle time" vs. "this site always hits the 2s cap" informs tuning and identifies chatty sites.
5. **Shared observer with Task 18**: The MutationObserver that detects settle also collects the mutations that occurred. These mutations are exactly the state delta that Task 18 needs for learning. A combined observer avoids installing two observers per action — settle detection = "mutations stopped" and the collected mutations become the `StateDelta`.

## Testing

- **Static page**: Click a button on a simple HTML page. Verify settle resolves in <50ms.
- **React SPA**: Interact with a React form. Verify settle waits for re-render (~100-200ms), not 2s.
- **Async loading**: Click a button that triggers a fetch + loading skeleton + content render. Verify settle waits for content.
- **Chatty site**: Test on a site with ads/analytics. Verify settle hits the 2s cap and does not hang.
- **CSS animations**: Page with infinite CSS animation. Verify settle resolves based on structural mutations, not animation frames.
- **Navigation**: Click a link that causes full page navigation. Verify no hang or unhandled rejection.
- **Empty page**: Run on `about:blank`. Verify no crash.
- **Regression**: Run existing e2e tests (Task 11). Overall session behavior should be the same or faster, never slower.
- **Timing comparison**: Log settle times across a session. Compare against the flat 2s of `waitForLoaded()` to quantify the improvement.

## Dependencies

- None. This is a standalone improvement to the existing action loop.

## Foundation For

- **011.features.01 (Task 17: Batch Action Execution)**: Uses `waitForDOMSettle()` as the inter-action timing mechanism between batched actions.
- **012.features.01 (Task 18: Domain Knowledge)**: The MutationObserver can be shared — settle detection collects the same mutations that Task 18 needs for state delta observation.
