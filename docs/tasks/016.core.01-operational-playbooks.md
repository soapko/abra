# Task 22: Operational Playbooks

## Problem

The current system has a fundamental mismatch between what it stores and what the LLM needs to plan effectively.

**What's stored:** Transition records — individual action→outcome pairs like `Clicking "Purple" div → "span" span appears`. These are disconnected observations with no sequencing, no targeting information, and biased toward previously-chosen options.

**What the LLM needs:** Concrete operation queues it can emit as a planned sequence of keyboard and mouse operations, executed mechanically without further LLM involvement until something unexpected happens.

**What's missing:** When the LLM plans action 2 in a batch (an element that doesn't exist yet), it currently uses `label` text matching — a runtime search, not a plan. And there's no stored playbook from prior visits that says "here are the exact selectors and positions to hit in order."

## Design

### Core Model

**LLM call = planning phase.** The LLM sees a screenshot (+ element annotations + stored playbooks from prior visits) and outputs a queue of concrete operations:

```
1. click selector "button.theme-trigger" at (0.31, 0.36)
2. waitForDOMSettle
3. click selector "[data-value='purple']" at (0.31, 0.53)
4. waitForDOMSettle
5. press Escape
6. click selector "button.style-trigger" at (0.42, 0.36)
7. waitForDOMSettle
8. click selector "[data-value='maia']" at (0.42, 0.46)
```

**Execution = mechanical.** The system runs each operation in order. No LLM involvement. Between each, a lightweight bail check: did the action fail? Did the URL change? If yes → stop, take a fresh screenshot, re-prompt the LLM with context: "executed 5 of 8, bailed at step 6 because [element not found], here's where you are now."

**Knowledge = recorded playbooks.** Prior visits store the exact selectors + relative coordinates that worked. On return visits, the LLM doesn't have to guess — it has the exact sequence from last time and can replay, modify, or compose new sequences from stored fragments.

### Relative Coordinate System

Absolute pixel coordinates break across viewport sizes, zoom levels, and responsive breakpoints. Store positions as ratios:

```typescript
interface RelativePosition {
  relX: number;           // x / viewportWidth  (0.0 - 1.0)
  relY: number;           // y / viewportHeight (0.0 - 1.0)
  viewportWidth: number;  // viewport at recording time (e.g. 1440)
  viewportHeight: number; // viewport at recording time (e.g. 900)
  scrollX: number;        // scroll offset at recording time
  scrollY: number;        // scroll offset at recording time
}
```

At replay:
```typescript
// Recompute absolute coordinates for current viewport
const absX = stored.relX * currentViewport.width;
const absY = stored.relY * currentViewport.height;
// Adjust for scroll difference if needed
const scrollAdjustedY = absY - (stored.scrollY - currentScrollY);
```

**Selector is primary targeting.** Coordinates are the fallback. If the selector finds the element, click it. If the selector breaks (DOM restructured), fall back to stored relative coordinates recomputed for the current viewport.

### Playbook Structure

```typescript
interface PlaybookOperation {
  type: 'click' | 'type' | 'press' | 'scroll' | 'hover' | 'wait';

  // Primary targeting (CSS selector)
  selector?: string;

  // Fallback targeting (relative coordinates from recording)
  position?: RelativePosition;

  // Action-specific data
  text?: string;       // for 'type'
  key?: string;        // for 'press'
  direction?: string;  // for 'scroll'
  amount?: number;     // for 'scroll'
  duration?: number;   // for 'wait'
}

interface Playbook {
  id: string;                      // deterministic hash
  name: string;                    // human-readable: "Select Purple theme color"
  domain: string;
  pagePath: string;
  operations: PlaybookOperation[];

  // Recording context
  recordedViewport: { width: number; height: number };

  // Reliability tracking
  successCount: number;
  failCount: number;
  lastUsed: string;
  createdAt: string;
}
```

### LLM Output Format

The LLM always outputs an array of concrete operations. Two modes:

**First visit (no playbooks):** LLM sees annotated screenshot. Element annotations provide both elementId and bounds. LLM outputs operations using elementIds (resolved to selectors + coordinates at execution time):

```json
{
  "thought": "I see the Theme button, let me customize the color scheme",
  "operations": [
    { "type": "click", "elementId": 33 },
    { "type": "wait", "duration": 300 },
    { "type": "click", "elementId": 33, "expectedLabel": "Purple" }
  ]
}
```

Wait — `expectedLabel` on the second action won't work because the element doesn't exist yet. On first visit, the LLM can only plan one action deep into unknown territory. This is fine — first visits are exploratory by nature. The system records what it discovers.

**Return visit (playbooks available):** LLM sees annotated screenshot + playbook summaries. It can reference stored playbooks by name or compose from fragments:

```json
{
  "thought": "I've been here before, let me set up the funky theme",
  "operations": [
    { "playbook": "dismiss-get-started-modal" },
    { "playbook": "select-theme-color", "variant": "Fuchsia" },
    { "playbook": "select-style", "variant": "Lyra" },
    { "type": "click", "elementId": 47 }
  ]
}
```

Or it can inline the operations directly if it wants to deviate from stored playbooks:

```json
{
  "thought": "I know the layout, going straight for the customizations",
  "operations": [
    { "type": "click", "selector": "button[data-testid='get-started']", "relX": 0.50, "relY": 0.65 },
    { "type": "wait", "duration": 300 },
    { "type": "click", "selector": "button.theme-trigger", "relX": 0.31, "relY": 0.36 },
    { "type": "wait", "duration": 300 },
    { "type": "click", "selector": "[data-value='fuchsia']", "relX": 0.35, "relY": 0.52 }
  ]
}
```

### Playbook Recording

Playbooks are recorded automatically from successful execution sequences:

1. During a session, track each operation that executes successfully: its selector, the element's bounds (converted to relative coords), and the viewport dimensions
2. When the LLM emits a new batch and the previous batch completed fully (no bail), save the completed batch as a playbook
3. Name the playbook from the LLM's `thought` or from a post-hoc summary
4. On subsequent visits, merge overlapping playbooks (same trigger element → keep the most recently successful one)

**Parameterized playbooks:** Some playbooks are "select X from dropdown" where X varies. The playbook stores the full sequence but marks which operation is the variable step. On replay, the LLM specifies the variant (e.g., "Fuchsia" instead of "Purple") and the system substitutes the selector/position for that option from prior observations.

### Playbook Storage

```
~/.abra/domains/{domain}/playbooks.json
```

Single JSON file per domain (not JSONL — playbooks are updated in place, not append-only):

```json
{
  "domain": "ui.shadcn.com",
  "playbooks": [
    {
      "id": "abc123",
      "name": "Dismiss Get Started modal",
      "pagePath": "/themes",
      "operations": [
        {
          "type": "click",
          "selector": "button:has-text('Get Started')",
          "position": { "relX": 0.50, "relY": 0.65, "viewportWidth": 1440, "viewportHeight": 900, "scrollX": 0, "scrollY": 0 }
        }
      ],
      "recordedViewport": { "width": 1440, "height": 900 },
      "successCount": 3,
      "failCount": 0,
      "lastUsed": "2025-06-15T10:30:00Z",
      "createdAt": "2025-06-12T08:00:00Z"
    }
  ],
  "optionMap": {
    "theme-color": {
      "Purple": { "selector": "[data-value='purple']", "position": { "relX": 0.35, "relY": 0.52, "viewportWidth": 1440, "viewportHeight": 900, "scrollX": 0, "scrollY": 0 } },
      "Fuchsia": { "selector": "[data-value='fuchsia']", "position": { "relX": 0.38, "relY": 0.52, "viewportWidth": 1440, "viewportHeight": 900, "scrollX": 0, "scrollY": 0 } }
    }
  }
}
```

### Execution Engine Changes

Replace the current `executeBatch` logic:

**Current flow:**
1. For each action: resolve label → install observer → execute → collect state → assert knowledge → bail checks

**New flow:**
1. For each operation in queue:
   a. **Target resolution:** Try selector first. If selector fails, compute absolute coords from relative position + current viewport, use coordinate click.
   b. **Execute:** Perform the operation (click, type, press, etc.)
   c. **Bail check:** Did it fail? URL change? Timeout?
   d. **Record:** Store the operation's actual selector + element position (for playbook creation)
   e. **Settle:** `waitForDOMSettle()` between operations
2. If bail: report to LLM with context ("executed N of M, bailed at step K because X")
3. If complete: save as playbook

**No more knowledge assertions during execution.** The current system's `assertDeltaMatch` checks create false bail-outs (e.g., one extra aria change causes mismatch even though the action succeeded). The playbook system is simpler: did the action execute without error? Did the next target resolve? If yes, keep going.

### What Gets Removed

- `TransitionRecord` interface and all related code
- `ActionSignature`, `ElementSignature` types (replaced by playbook operations)
- `assertDeltaMatch()` — no more structural assertions during execution
- `StateDelta` recording during batch execution (observer still used for DOM settle, not for knowledge)
- `getKnowledgeSummary()` — replaced by playbook summary injection
- `findTransition()`, `recordTransition()`, `confirmTransition()`, `updateTransition()`
- JSONL storage format
- Label resolution in `executeBatch` (replaced by selector + coordinate fallback)

### What Stays

- `waitForDOMSettle()` — still needed between operations
- Bail-out on URL change, action failure
- `executeAction()` core logic — still maps operations to browser commands
- Portal scanning, shadow DOM handling — still needed for element discovery
- Screenshot annotation — still needed for LLM visual input
- Speech bubble overlay — still needed for persona expression
- Page analyzer — still extracts elements, now also captures bounds for coordinate storage

### What Gets Added

- `PlaybookStore` class — load, save, find, record, merge playbooks
- `PlaybookOperation` type — replaces `Action` in the execution pipeline
- Relative coordinate storage — capture element bounds as viewport ratios
- Playbook summary for LLM injection — "Available sequences: dismiss modal, select theme color [options: ...], ..."
- Playbook reference in LLM output — `{ "playbook": "name", "variant": "X" }`
- Coordinate recomputation — relative → absolute at execution time based on current viewport
- Viewport capture — record width/height/scroll when storing positions

## E2E Analysis: Gaps Identified

### GAP 1: First visit produces zero playbooks (bootstrapping problem)

On first visit, the LLM only produces 1-action batches because it doesn't know what's behind any dropdown. The rule "save as playbook when batch has 2+ operations" means first visits create nothing.

**Resolution (V1):** Post-session grouping pass. After a goal completes, analyze the full action log and stitch consecutive single-action iterations into candidate playbooks when they form a causal chain (action N opened a container, action N+1 interacted with an element inside it). Hash the operation sequence for the playbook ID.

### GAP 2: Unknown variant handling

When the LLM references a playbook variant that isn't in the option map (e.g., `variant: "Lyra"` when only `"Maia"` was recorded), expansion fails. The system can't produce an operation because it has no selector or position.

**Resolution (V1):** Expansion stops at the unknown variant and returns a partial queue of operations up to that point. The executor runs the partial queue, then bails with feedback: "Executed N operations. Bailed: variant 'Lyra' not found for playbook 'Select style'. The dropdown is currently open." The LLM sees a fresh screenshot showing the open dropdown and picks the target by elementId.

**Implication:** Playbook expansion is NOT a simple flatten. It returns `{ queue: PlaybookOperation[], incomplete?: { playbookName, variant, reason } }`.

### GAP 3: Option map population is too slow

Recording only the variant the persona clicked means the option map grows by 1 entry per visit. After 5 visits choosing different colors, you know 5 variants.

**Resolution (V2):** After a trigger operation that causes new elements to appear (dropdown opening), run a lightweight page analyzer diff between the pre-action and post-action element lists. Capture all new interactive elements as candidate variants for that playbook's variable step. A single visit populates the entire option map for a dropdown.

**V1 workaround:** Accept slow growth. Unknown variants fall through to fresh planning (GAP 2 resolution). The LLM picks by elementId, and the system records that variant for next time.

### GAP 4: Playbook naming

The task doc doesn't specify how playbook names are generated. These names are what the LLM sees in the prompt and references in its output.

**Resolution (V1):** Add a `sequenceName` field to the LLM output schema. When the LLM emits inline operations, it provides a name. Fallback: auto-generate from operations, e.g., "click [Theme] → click [Fuchsia]" → "Select Theme Fuchsia". Post-session grouping uses auto-generated names.

### GAP 5: New playbooks vs. replays

When the LLM chains 4 existing playbook references, should the composition become a new composite playbook?

**Resolution (V1):** No. Playbook references are replays — each referenced playbook gets `successCount++`. Only save as a new playbook when the batch contains **inline operations** (not playbook references). Inline operations are new discoveries worth recording.

### GAP 6: Bail feedback format

When bailing mid-execution, the feedback to the LLM needs rich context — not just "element not found" but which playbook was being executed and where in the sequence it failed.

**Resolution (V1):** Bail message format: "Executed {N} of {M} operations from playbook '{name}'. Bailed at step {K}: {reason}. Current state: {what's visible, e.g., 'dropdown is open'}."

### GAP 7: `tryClickWithFallback` needs coordinate-only mode

The existing fallback chain takes a `PageElement` to get bounds. In playbook mode, there's no `PageElement` — there's a stored `RelativePosition` recomputed to absolute coordinates.

**Resolution (V1):** Extend `tryClickWithFallback` (or create a parallel path) that accepts `{ selector?: string, absX: number, absY: number }` directly. Selector-first, coordinate-fallback, same as current pattern but without requiring a `PageElement`.

### GAP 8: `waitForDOMSettle` is implicit, not an explicit operation

The task doc examples show explicit `waitForDOMSettle` operations in the queue. But the implementation should auto-inject settles between operations — the LLM shouldn't have to emit them manually.

**Resolution (V1):** `waitForDOMSettle()` is called automatically between every operation by the executor. It is NOT an operation type in the schema. Remove it from the examples.

### GAP 9: Playbook deduplication

Multiple sessions may create equivalent playbooks (same selectors, different names) for the same interaction sequence.

**Resolution (V2):** Hash the operation sequence (selectors + types) to produce the playbook ID. On save, check if an equivalent hash already exists. If so, merge (update positions, increment successCount, keep the more descriptive name).

**V1 workaround:** Accept duplicates. They compete for selection by the LLM. Low-success ones get ignored naturally.

### GAP 10: `state-observer.ts` can be fully removed

The state observer (`installObserver`, `collectObservation`, `teardownObserver`) is only imported in `session.ts` for knowledge assertion during batch execution. The `waitForDOMSettle` in `dom-settle.ts` has its own separate MutationObserver. Nothing else depends on `state-observer.ts`.

**Resolution (V1):** Delete `state-observer.ts` entirely during cleanup.

---

## V1 Scope (Minimum Viable Playbooks)

### Include

- `PlaybookStore` class — load, save, find, record, summary generation
- Playbook recording from successful 2+ inline-operation batches
- Post-session grouping: stitch consecutive 1-action iterations into playbooks based on causal chains
- Playbook summary injection into LLM prompt (replaces knowledge summary)
- Playbook reference expansion in LLM output parsing, with partial expansion for unknown variants
- `sequenceName` field in LLM output schema, auto-generated fallback for post-session playbooks
- Selector-first execution with relative coordinate recomputation fallback
- `tryClickWithFallback` extended to accept `{ selector?, absX, absY }` directly
- Auto-inject `waitForDOMSettle()` between operations (not an explicit operation type)
- Rich bail feedback: playbook name, step number, reason, current visible state
- Inline operations only create new playbooks; playbook references only increment success counts
- Remove: `TransitionRecord`, `StateDelta`, `assertDeltaMatch`, `state-observer.ts`, label resolution, JSONL storage, `getKnowledgeSummary()`

### Defer to V2

- Parameterized variants / option maps (V1 relies on GAP 2 fallthrough: unknown variant → bail → LLM picks by elementId → record for next time)
- Inter-operation page scanning for option discovery (populating all dropdown options at once)
- Playbook deduplication / hash-based merging
- Viewport-range-specific playbooks (V1 trusts selector-first; coordinates are best-effort)
- Post-hoc LLM naming of playbooks (V1 uses `sequenceName` from LLM or auto-generated names)

### V1 Expected Behavior

- **Visit 1 (cold):** Exploratory. 1 action per LLM call. Post-session grouping creates 3-5 playbooks from the action log.
- **Visit 2 (warm):** LLM sees playbook summaries, references them in output. Batches 3-5+ operations per call. Inline operations for anything not covered by playbooks. New playbooks created from inline batches.
- **Visit 3+ (hot):** LLM composes stored playbooks to cover most of the goal. 1-2 LLM calls for a full goal. Unknown variants fall through to planning but are recorded for next time.

---

## Implementation Plan

### Phase 1: PlaybookStore + Coordinate Infrastructure

**Files:** new `src/lib/playbook-store.ts`, `src/lib/page-analyzer.ts`

1. Define types: `RelativePosition`, `PlaybookOperation`, `Playbook`, `PlaybookStore`
2. `PlaybookStore.load(domain)` — read `~/.abra/domains/{domain}/playbooks.json`
3. `PlaybookStore.save(domain)` — write JSON atomically
4. `PlaybookStore.record(name, operations[], viewport)` — add playbook, generate hash ID
5. `PlaybookStore.find(name)` — lookup by name
6. `PlaybookStore.getSummary(domain)` — generate human-readable summary for LLM injection
7. `toAbsolute(relPos, currentViewport) → {x, y}` — recompute coordinates at replay time
8. `toRelative(absPos, viewport) → RelativePosition` — convert element bounds at recording time
9. Update `PageElement` bounds to also provide viewport-relative conversion helper

### Phase 2: LLM Output Format + Prompt Changes

**Files:** `src/lib/llm.ts`

1. Define new output schema:
   - `operations[]` array replacing `actions[]`
   - Each operation: `{ type, elementId?, selector?, relX?, relY?, playbook?, variant?, text?, key?, sequenceName? }`
   - `sequenceName` field for naming new inline sequences
2. Update system prompt:
   - Replace knowledge summary section with playbook summary section
   - Explain the operation queue model: "You output a queue of operations. The system executes them mechanically in order."
   - Remove all `label` field documentation
   - Add playbook reference documentation: "Reference stored playbooks by name. Specify variant for parameterized steps."
3. Update response parsing:
   - Parse `operations[]` (new format)
   - Backward-compat: parse `actions[]` (old format) → convert to operations
   - Handle playbook references: expand inline, bail on unknown variant
4. `expandPlaybookReferences(operations[], store) → { queue: PlaybookOperation[], incomplete? }`

### Phase 3: Execution Engine

**Files:** `src/lib/session.ts`, `src/lib/action-executor.ts`

1. New `executeOperationQueue(queue, browser, pageState, bail?)` function:
   - For each operation in queue:
     a. Resolve target: selector first → coordinate fallback (recomputed from relative)
     b. Execute: `tryClickWithFallback` for clicks, existing handlers for type/press/scroll
     c. `waitForDOMSettle()` automatically between operations
     d. Bail check: action error, URL change, timeout
     e. Record: actual selector + element bounds (as relative position) for playbook creation
   - Returns: `{ completed: number, total: number, bailReason?: string, recordedOps: RecordedOperation[] }`
2. Extend `tryClickWithFallback` to accept `{ selector?: string, absX: number, absY: number }` without requiring `PageElement`
3. Update `runGoal` loop:
   - Pass playbook summaries (not knowledge summaries) to LLM
   - After execution, record playbooks from inline operations (2+ ops, fully completed)
   - On bail: rich feedback to LLM including playbook name + step + reason

### Phase 4: Post-Session Playbook Stitching

**Files:** `src/lib/playbook-store.ts`, `src/lib/session.ts`

1. After goal completion, analyze action log:
   - Group consecutive 1-action iterations where action N+1 interacted with an element that appeared after action N (causal chain detection)
   - Create candidate playbooks from each group (2+ operations)
   - Auto-generate names from operation descriptions
2. Save stitched playbooks with `successCount: 1`

### Phase 5: Migration & Cleanup

**Files:** `src/lib/domain-knowledge.ts` (delete), `src/lib/state-observer.ts` (delete), `src/lib/session.ts`, `src/lib/llm.ts`, `src/lib/action-executor.ts`

1. Delete `state-observer.ts` entirely
2. Delete `domain-knowledge.ts` entirely (or gut to empty re-exports if anything still imports)
3. Remove from `session.ts`: `installObserver`, `collectObservation`, `teardownObserver`, `assertDeltaMatch`, `findTransition`, `recordTransition`, `confirmTransition`, `updateTransition`
4. Remove from `llm.ts`: `Action.label` field, label resolution prompt text, old `actions[]` schema (after backward-compat period)
5. Remove from `action-executor.ts`: label resolution in `executeBatch`
6. Remove JSONL storage/loading code
7. Update CLI: remove `--learn`/`--no-learn`, add `--no-playbooks`
8. Update types: remove `TransitionRecord`, `ActionSignature`, `ElementSignature`, `StateDelta`

## Edge Cases

### Responsive breakpoints
A playbook recorded at 1440x900 may have elements in completely different positions at 768x1024 (mobile layout). The selector is primary targeting — if the selector works, position doesn't matter. If both fail, bail and re-sense. V2 accumulates viewport-range-specific playbooks.

### Scroll-dependent elements
Elements below the fold have positions relative to the viewport at the current scroll. Store `scrollY` at recording time. At replay, if scroll differs significantly, the coordinate recomputation adjusts. If the element is off-screen, scroll first (the playbook should include a scroll operation).

### Dynamic content / data-dependent pages
Playbooks for pages with dynamic content (search results, user-specific data) will have lower success rates. The `failCount` tracker identifies these — the LLM learns not to rely on flaky playbooks.

### Parameterized options (V2)
A "select theme color" playbook with `variant: "Purple"` needs an option map: for each known variant, store its selector and position. V1 skips this — unknown variants bail, LLM picks by elementId, new variant is recorded for next visit. V2 populates the option map by scanning all dropdown options after a trigger.

### Playbook composition ordering
The LLM's plan `[dismiss modal, select color, select style, select radius]` only works because each step leaves the page in the right state for the next. The system does not validate ordering — it trusts the LLM's sequence and bails if anything goes wrong. This is explicitly by design.

### First-visit exploration ceiling
On first visit, average batch size will remain 1 (same as today). The improvement only kicks in on visit 2+. This is acceptable — first visits are inherently exploratory. The post-session stitching ensures visit 2 has playbooks to work with.

## Success Criteria

1. On first visit, Abra explores normally (1 action per LLM call). Post-session stitching creates playbooks from the action log.
2. On second visit, Abra references stored playbooks and batches 3-5+ operations per LLM call.
3. On third+ visit, Abra executes a full goal (e.g., "set theme to Fuchsia + Lyra + Large radius") in 1-2 LLM calls by composing stored playbooks.
4. Viewport size changes don't break playbooks — selectors still work, coordinates recompute as fallback.
5. When a playbook fails mid-execution, Abra bails cleanly with rich context and re-plans from current state.
6. Average LLM calls per goal decreases by 50%+ on return visits compared to current system.
7. `state-observer.ts` and `domain-knowledge.ts` are fully removed. No JSONL files created.
8. Unknown playbook variants fall through gracefully — the dropdown is open, the LLM picks by elementId, the variant is recorded for next time.
